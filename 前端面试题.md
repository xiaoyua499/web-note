# 前端面试题

## javascript面试题

### 1、javascript有哪些数据类型，它们的区别？

1. **一共8中数据类型**
   1. 基本数据类型(简单数据类型)：string/number/boolean/null/undefined/synbol/bigint
      1. symbol数据类型是ES6中新出的数据类型，创建（`Synbol()`）之后独一无二并且不可变，不能使用 `new Symbol()`创建
      2. Bigint数据类型是ES6中新出的数据类型,数据覆盖范围大，能够解决超出普通数据类型范围报错的问题
         1. 创建方法：
            - 整数末尾直接加n：647326483767797n
            - 调用BigInt()构造函数：BigInt("647326483767797")
   2. 复杂数据类型（引用数据类型）：object（对象、数组、正则）
2. **区别：**
   1. 声明变量时的存储分配
      1. 基本数据类型存储在栈中
      2. 复杂数据类型存储在堆中
   2. 不同的访问机制
      1. 基本数据类型可以直接访问
      2. 引用数据类型访问引用地址，根据引用地址找到堆中实体
   3. 复制变量时不同
      1. 基本数据类型：将原始值的副本赋值新的变量
      2. 引用数据类型：将引用地址赋值给新的值

### 2、闭包？

1. **什么是闭包？**

   方法里返回一个方法

   ```js
   function a(){
     let a1 = 1
     return function () {
       return a1
     }
   }
   ```

2. **闭包的意义**

   1. 延长变量的生命周期
   2. 创建私有环境

3. 例如`Vue`中

   ```js
   data(){
     return{
       
     }
   }
   ```


### 3、函数节流与防抖

1. **函数防抖**

   > 函数防抖（debounce），就是指触发事件后，在延迟时间内函数只能执行一次，如果触发事件后在延迟时间内又触发了事件，则会重新计算函数延执行时间。等延迟时间计时完毕，则执行目标代码。
   
   ```js
   封装防抖
   //func 要执行的函数，wait要等待的时间
   function debounce(func, wait) {
     let timeout;
     return function () {
       // 清空定时器
       if(timeout) clearTimeout(timeout);
       timeout = setTimeout(func, wait)
     }
   }
   ```

2. **函数节流**

   > 函数节流（throttle），在规定时间内，频繁触发的事件被限制为只允许触发一次
   
   **时间戳实现**
   
   ```js
   function throttle(fn, delay) {
     let previous = 0;
     // 使用闭包返回一个函数并且用到闭包函数外面的变量previous
     return function() {
         let args = arguments;
         let now = new Date();
         if(now - previous > delay) {
             fn.apply(this, args);
             previous = now;
         }
     }
   }
   ```
   
   **定时器实现**
   
   ```js
   function throttle(func, delay) {
     var delay = delay || 1000;
     var timer = null;
     return function(args) {
       var context = this;
       var nowDate = new Date();
       var now = nowDate.getTime();
       if (!timer) {
         timer = setTimeout(function() {
           func.call(context, args);
           timer = null;
         }, delay)
       }
     }
   ```
   

### 4、原型与原型链

1. **原型可以解决什么问题**

   对象共享属性和方法

2. **谁有原型**

   函数：`prototype`

   对象：`__proto__`

3. **对象查找属性或者方法的顺序**

   对象本身-->构造函数-->对象的原型-->构造函数的原型-->当前原型的原型中

4. **原型链**

   1. 是什么？

      把原型串联起来

   2. 原型链的最顶端是null

### 5、localStorage、sessionStorage、cookie的区别

1. 共同点

   在客户端存放数据

2. 区别

   1. 存放数据的有效期不同

      sessionStorage：仅在当前浏览器窗口有效，关闭后自动删除

      localStorage：始终有效、窗口或浏览器关闭也会一直存在，除非手动删除

      cookie：只在设置的cookie过期时间内有效

   2. 能过存储的容量不同

      cookie存储量不能超过4k

      localStorage、sessionStorage不能超过5M

      **注意**：不同的浏览器能存储的大小是不同的

### 6、延迟加载JS有哪些方式？

`async、defer`

例如：

```html
<script async type="text/javascript" src='script.js'></script>
<script defer type="text/javascript" src="script.js"></script>
```

defer:等html全部加载完成，才会执行js代码，顺次执行js脚本

async：async与html解析同步进行，按加载速度执行js脚本

<img src="https://images3.pianshen.com/626/e4/e4910fe7a9a6234e0f2096bbef6fdcd2.png" style="zoom:67%;" />

### 7、`null`和`undefined`的区别

**null**是一个表示“无”的对象（空对象指针），转为数值为0

**undefined**是一个表示“无”的原始值，转为数值为NaN

### 8、== 与 === 的区别

== ： 比较值

​	不同的类型进行比较时会通过调用valueOf转换（JavaScript 调用 `valueOf` 方法将对象转换为原始值。你很少需要自己调用 `valueOf` 方法；当遇到要预期的原始值的对象时，JavaScript 会自动调用它。）

=== ： 比较值与类型

### 9、JS微任务与宏任务

1. js是单线程语言

2. js代码执行流程：

   `同步任务==>事件循环【微任务(清空所有的微任务)==>宏任务】`

3. 事件循环(请求、定时器、事件...)
   1. 微任务：`promise.then`
   2. 宏任务:`setTimeout..`

例如：

```js
for(var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i)
  },1000*i)
}
console.log(2222)
//2222
//3
//3
//3

setTimeout(function () {
  console.log('1')
})
new Promise((resolve) => {
  console.log('promise 1')
  resolve()
}).then(() => {
  console.log('微1')
}).then(() => {
  console.log('微2')
})
console.log(2)

//promise 1
//2
//微1
//微2
//1
```

### 10、JS作用域

1. 除函数外，js没有块级作用域
2. 作用域链：内部可以访问外部的变量，外部不能访问内部的变量
3. 注意：JS有变量提示机制【变量悬挂声明】
4. 优先级：声明变量 > 声明普通函数 > 参数 > 变量提升

**面试时怎么看**

1. 本层作用域有没有此变量【变量提升】
2. 注意：js除函数外没有块级作用域
3. 注意：优先级

例题1：

```js
function c() {
  var b = 1;
  function a() {
    conso1e.1og(b）//undefined
    var b = 2;
    console.log(b) //2
  }
  a();
  console.log(b) //1
  }
c()
```

例题2：

```js
var name ='a'
function(){
  if(typeof name ='undefined')
    var name ='b';
    console.log('111'+name);
  }elsef
  	console.log('222'+name)
})()
// 111b
```

### 11、JS作用域+this指向+原型链

例题1：

```js
function Foo(){
  getName=function(){console.log(1)}//注意是全局的vindow,
  return this;
}
Foo.getName function(){console.log(2)}
Foo.prototype.getName function(){console.log(3)}
var getName function(){console.log(4)}
function getName(){
	console.log(5)
}
Foo.getName();//2
getName();//4
Foo().getName();//1
getName();//1
new Foo().getName();//3
```

例题2:

```js
var o = {
  a:10,
  b:{
    fn:function(){
      console.log(this.a)
      console.log(this)
   	 }
    }
}
o.b.fn();
//{fn:f}
```



例题3：

```js
//头条考题
window.name = 'ByteDance'
function A(){
	this.name = 123;
}
A.prototype.getA = function () {
  console.log(this )
  return this.name + 1;
}
let a = new A();
let funcA = a.getA;
/* 相当于 let funcA = function () {
console.log(this)
return this.name + 1;
}*/
funcA() //ByteDance1

//window
```

例题4：

```js
var length 10;
function fn(){
return this.length + 1;
}
var obj = {
  length:5,
  test1:function(){
    return fn();
  }
}
obj.test2 = fn;
console.log(obj.test1());//11
console.log(fn()===obj.test2());//false
console.log(obj.test1()==obj.test2());//false
```

### 12.判断变量是不是数组

1. isArray

   ```js
   var arr = [1,2,3]
   console.log(Array.isArray(arr))
   ```

2. instanceof

   ```js
   var arr = [1,2,3]
   console.log(arr instanceof Array)
   ```

3. 原型 prototype

   ```js
   var arr = [1,2,3]
   console.log(Object.prototype.toString.call(arr).indexOf('Array'))
   ```

4. isPrototypeOf()

   ```js
   var arr = [1,2,3]
   console.log(Array.prototype.isprototypeOf(arr))
   ```

5. constructor

   ```js
   var arr = [1,2,3]
   console.log(arr.constructor.toSting().indexOf('Array'))
   ```


### 13.`slice、splice`有什么功能,是否会改变原数组

1. `slice`用来截取数组

   `例如：slice(3)、slice(1,3)、slice(-3)`并且会返回一个新数组

2. `splice`用来：插入、删除、替换

   该方法会改变原数组并返回删除的元素

### 14.数组去重

1. `new Set`

   ```js
   var arr = [1, 3, 2, 2, 1, 4, 5, 5, 1, 3]
   function unique(arr) {
     return [...new Set(arr)]
     // return Array.from(new Set(arr))
   }
   console.log(unique(arr));
   ```

2. `indexOf`

   ```js
   var arr = [1, 3, 2, 2, 1, 4, 5, 5, 1, 3]
   function unique(arr) {
     var arr1 = []
     for (var i = 0; i < arr.length; i++) {
       if (arr1.indexOf(arr[i]) == -1) {
         arr1.push(arr[i])
       }
     }
     return arr1
   }
   console.log(unique(arr));
   ```

3. `sort`

   ```js
   var arr = [1, 3, 2, 2, 1, 4, 5, 5, 1, 3]
   function unique(arr) {
     arr = arr.sort()
     var arr1 = []
     for (var i = 0; i < arr.length; i++) {
       if (arr[i] !== arr[i + 1]) {
         arr1.push(arr[i])
       }
     }
     return arr1
   }
   console.log(unique(arr));
   ```

### 15.大数组中包含了4个小数组，分别找到每个小数组中的最大值然后把它们串联起来，形成一个新数组

例：

```js
var arr = [
  [4, 5, 1, 3],
  [13, 27, 18, 26],
  [32, 35, 37, 39],
  [1000, 1001, 587, 1]
]
function fnArr(arr) {
  var newArr = []
  arr.forEach((item) => {
    newArr.push(Math.max(...item))
  })
  return newArr
}
console.log(fnArr(arr));
```

### 16.给字符串对象定义一个addPrefix函数当传入一个字符串str时，它会返回新的带有指定前缀的字符串

例如：`console.log("world".addPrefix("hello")) 控制台会输出："helloworld"`

```js
String.prototype.addPrefix = function (str) {
  return str + this
}
console.log('world'.addPrefix('hello'));
```

### 17.找出字符串中出现次数最多的字符及其出现的次数

例题1：

```js
var str = 'jjjjjjsdfsdijfhaliuyewhjhjhweufghmnnvzxcvj'
function getMaxCount(str) {
  var maxCount = 0
  var maxCountChar = ''
  while (str) {
    var length = str.length
    var char = str.charAt(0)
    var reg = new RegExp(char, 'g')
    str = str.replace(reg, '')
    var newLength = str.length
    var charCount = length - newLength
    if (charCount > maxCount) {
      maxCount = charCount
      maxCountChar = char
    }
  }
  return {
    maxCount,
    maxCountChar
  }
}
maxCountChar = getMaxCount(str).maxCountChar
maxCount = getMaxCount(str).maxCount
console.log('出现最多的字符为：' + maxCountChar);
console.log('出现的次数为：' + maxCount);
```

### 18.new操作符具体做了什么

1. 创建了一个空的对象
2. 将空对象的原型，指向构造函数的原型
3. 将空对象作为构造函数的上下文（改变this指向）
4. 对构造函数有返回值的处理判断

```js
//手写 new
function Fun (age,name) {
  this.age = age
  this.name = name
}
function cerate (fn, ...args) {
  //1. 创建了一个空的对象
  var obj = {}
  //2. 将空对象的原型，指向构造函数的原型
  Object.setPrototypeOf(obj,fn.prototype)
  //3. 将空对象作为构造函数的上下文（改变this指向）
  var result = fn.apply(obj,args)
  //4. 对构造函数有返回值的处理判断
  return result instanceof Object ? result : obj
}
console.log(create(Fun,18,'张三'))
```

### 19.`call、apply、bind`的区别

1. 共同点：
   1. 可以改变this指向
   2. 语法：函数.call()、函数.apply()、函数.bind()
2. 区别
   1. call、apply会立即执行，bind返回的是一个函数而不会立即执行需要加（）才会执行
   2. 参数不同：apply第二个参数为数组的形式而call和bind有多个参数是需要逐一书写

### 20.`sort`

1. 用sort()对[3,15,8,29,102,22]排序

<img src="D:\Desktop\文件\web\web 笔记\图片\uTools_1659444863701.png" style="zoom: 33%;" />

2. 当function(x,y)得到的返回值小于0，x会被移动到y前面(升序排序)

```js
 var arr = [1,22,113,12,45,32,334]
 console.log(arr.sort(function(x,y){
   return x - y
 }));
//[1, 12, 22, 32, 45, 113, 334]
```

3. 当function(x,y)得到的返回值大于0，x会被移动到y后面(降序排序)

```js
var arr = [1,22,113,12,45,32,334]
console.log(arr.sort(function(x,y){
   return y - x
}));
//[334, 113, 45, 32, 22, 12, 1]
```

4. 当function(x,y)得到的返回值等于0，x和y的位置相对不变（不是所有浏览器都遵守）

### 21.深拷贝与浅拷贝

1. 共同点：都是复制

2. 区别：

   1. 浅拷贝：只复制引用，不复制值

   2. 深拷贝：复制值

      ```js
      var obj = {
        a:1,
        b:2
      }
      var obj4 = JSON.parse(JSON.stringIfy(obj))
      ```

### 22.var、let、const有什么区别

1. var、let声明变量，const声明常量
2. var具有变量提升机制，let和const没有变量提升机制
3. var不支持块级作用域，let和const支持块级作用域
4. var可以重复声明同一变量，let和const不可以重复声明同一变量

### 23.合并对象

1. `Object.assign`

   ```js
   const a = {a:1, b:4}
   const b = {b:2, c:3}
   let obj  = Object.assign(a,b)
   console.log(obj)
   ```

2. 拓展运算符（`...`）

   ```js
   const a = {a:1, b:4}
   const b = {b:2, c:3}
   let obj = {...a, ...b}
   const.log(obj)
   ```

3. 封装方法

   ```js
   const a = {a:1, b:4}
   const b = {b:2, c:3}
   function extend (target, source) {
     for (var key in source) {
       target[key] = source[key]
     }
     return target
   }
   console.log(extend(a,b))
   ```

### 24.箭头函数和普通函数有什么区别？

1. this指向的问题
   - 箭头函数中的this只在箭头函数定义时决定，不可修改（通过call、apply、bind）
   - **箭头函数的this指向定义时外层第一个普通函数的this**
2. 箭头函数不能new（不能当作构造函数）
3. 箭头函数没有prototype
4. 箭头函数没有arguments

### 25.Promise

1. **Promise有几种状态**
   - 三种状态：pending(进行中)、fu1fi11ed(已成功)、rejected(已失败)
2. **Promise如何解决地狱回调？**
   - then里而可以return Promise,来防止地狱回调

### 26.find和filter的区别

1. filter返回一个新的数组
2. find返回匹配到的第一个内容

### 27.some和every的区别

1. some：数组中任意一项匹配则返回true

2. every：数组中各项全部匹配返回true

   ```js
   var arr = [1, 3, 4, 7, 8, 2]
   var arr1 = arr.some(val => {
     return val > 4
   })
   var arr2 = arr.every(val => {
     return val > 4
   })
   console.log(arr1, arr2) // true false
   ```

   



## HTML+CSS面试题

### 1.行内元素有哪些？块级元素有哪些？空（void）元素有哪些？

1. 行内元素（不独占一行，且不能设置宽高）：span、img、input...
2. 块级元素（独占一行，且可以设置宽高）：div、p、h1—h6、footer、header、section...
3. 空元素：br、hr..
4. 元素之间的转换问题：
   - `display：inline；`把某元素转换成行内元素
   - `display：block；`把某元素转换成块元素
   - `display：inline-block；`把某元素转换为行内块元素（不独占一行，并且可以设置宽高）

### 2.页面导入样式时，使用link和@import有什么区别？

1. link的兼容性比@import好
2. 浏览器先加载link标签，后加载@import

### 3.title与h1、b与strong、i与em之间的区别？

1. **title与h1的区别：**
   1. 定义：
      - title：网站标题
      - h1：网站内容标题
   2. 区别：
      - title显示在网页的标题上，h1显示在网页内容上
2. **b与strong的区别：**
   1. 定义：
      - b：实体标签，用来给文字加粗
      - strong：逻辑标签，用来加强语气
   2. 区别：
      - b标签只加粗样式，没有实际含义
      - strong标签表示标签内字符比较重要，用以强调
3. **i与em的区别：**
   1. 定义：
      - i：实体标签，用来做文字倾斜
      - em：逻辑标签，用来强调文字内容
   2. 区别：
      - i：没有实际含义
      - em：表示标签内字符比较重要，用以强调

### 4.img标签中title和alt有什么区别？

1. title：鼠标移入到图片显示的值
2. alt：图片无法加载时显示的值
3. 在seo层面，爬虫抓取不到图片的内容，所以前端在写img标签的时候为了增加seo效果要加入alt属性来描述这张图片的内容或关键词

### 5.png、jpg、webp、gif这些图片格式有什么区别，分别什么时候用？

1. png：无损压缩，尺寸体积比jpg/jpeg大，适合做小图标
2. jpg：采用压缩算法，会产生失真，比png体积小，适合做中大图片
3. webp：同时支持有损或无损压缩，相同质量的图片webp具有更小的体积，但兼容性低

### 6.语义化标签

1. 常用的新增语义化标签：header(头部标签)、nav（导航标签）、article(内容标签)、setion(定义文档某个区域)、aside(侧边栏标签)、footer(尾部标签)
2. 特点：
   1. 易读性和维护性更好
   2. seo成分更好，更好爬取
   3. IE8不兼容

### 7.`::before`和`:after`中双冒号和单冒号有什么区别？这两个伪元素有什么用

1. 区别：

   `:`是伪类、`::`是伪元素

2. 作用：

   清楚浮动、样式布局

### 8.如何关闭IOS键盘首字母自动大写

input标签添加`autocapitalize='off'`属性

### 9.怎么让Chrome支持小于12px的文字

1. Chrome默认字体大小为16px，支持最小字体大小为12px
2. 添加`-webkit-transform:scale(1.6);`缩放属性

### 10.`rem`与`em`的区别

1. 使用rem单位的时候，页面转换为像素大小取决于**叶根元素的字体大小，即HTML元素的字体大小**。根元素字体大小乘rem的值。
2. 当使用em单位的时候，像素值是将**em值乘以使用em单位的元素的字体大小**。当使用em的单位没有设置字体大小时，将会根据**父元素的字体大小计算**。

### 11.rem适配

1rem的大小就是根元素的font-size的值。通过设置根元素的font-size的大小来控制整个HTML文档内的文字大小、元素宽高、内外边距等。根据移动设备的宽度大小来实现适应，不同的设备都展示一致的页面效果。

### 12.响应式

1. 什么是响应式？

   同一个URL可以响应多端

2. 语法：

   ```css
   @media only screen and (max-width:1000px) {
     
   }
   only:可以排除不支持媒体查询的浏览器
   screen：设备类型
   max-width | max-height
   min-width | min-height
   ```

### 13.介绍一下CSS盒子模型

1. CSS盒子模型包括：

   1. 标准模型

      <img src="D:\Desktop\文件\web\web 笔记\图片\uTools_1659594340939.png" style="zoom: 50%;" />

   2. IE盒子模型

      <img src="D:\Desktop\文件\web\web 笔记\图片\uTools_1659594410509.png" style="zoom: 60%;" />

2. 组成：

   - 标准盒子模型：margin、border、padding、content
   - IE盒子模型：margin、content（border + padding + content）

3. 通过CSS转换盒子模型：

   - `box-sizing: content-box;`标准盒子模型
   - `box-sizing: border-box;`IE盒子模型

### 14.`line-height`和`height`的区别

1. **height**是盒子的高度
2. **line-hright**是每一行文字的高度，会改变盒子的高度

### 15.CSS选择符有哪些？那些属性可以继承？

1. CSS选择符：

   - 通配符（*）、id选择器（#）、类选择器（.）、标签选择器（div、p、span...）、相邻选择器（+）、后代选择器（ul li）子元素选择器（>）、属性选择器（div[]）

   - ```css
     相邻选择器（+）选择下一个兄弟
     div + li{}
     ```

2. 那些属性可以继承
   - `font-size`、`color`、`line-height`...
3. 不可以继承
   - `border`、`padding`、`margin`...

### 16.CSS优先级

​	！important > 内联样式 > id > class > 标签/伪元素选择器 > 通配符

### 17.纯CSS画三角形

```css
div{
  width: 0;
  height: 0;
  border: 125px solid transparent;
  border-bottom-color: pink;
}
```

### 18.不设置宽度高度如何给盒子设置垂直居中

1. 利用`display：flex`
2. 利用定位（**子绝父相**）+`transform: translate(-50%, -50%)`

### 19.`dispaly`有哪些值？说明它们的作用

1. none （隐藏元素）
2. block （将元素转换为块元素）
3. inline （将元素转换为行内元素）
4. inline-block （将元素转换为行内块元素）

### 20.对BFC的理解

1. BFC（block formatting context）块级格式化上下文
2. BFC原则：如果一个元素具有BFC ，那么其内部元素将不影响外面的元素
3. 如何触发BFC：
   - float的值为非none
   - overflow的值为非visible
   - display的值为：inline-block、table-cell...
   - position的值为：absoute、fixed...

### 21.清除浮动

1. 触发BFC

2. 添加伪元素

   ```css
   :after{
     content: '';
     display: block;
     clear: both;
   }
   ```

3. 多创建一个盒子，添加样式：`clear：both；`

### 22.定位

| 值       | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| static   | 默认值，无定位                                               |
| absolute | 绝对定位，根据第一个有relative属性的父元素进行定位，脱离文档流 |
| fixed    | 固定定位，相对于浏览器窗口进行定位                           |
| relative | 相对定位，相对于原位置进行定位，不脱离文档流。当**left、right、top、bottom**同时存在时以**left、top**为准 |

### 23.圣杯布局与双飞翼布局

<img src="D:\Desktop\文件\web\web 笔记\图片\1659616756765.png" style="zoom:50%;" />

1. 圣杯布局

   ```html
   <boby>
     <header>头部</header>
     <div class="clearfix wrapper">
       <div class="center">主区域</div>
       <div class="left">左区域</div>
       <div class="right">右区域</div>
     </div>
   </boby>
   
   <style>
     .left, .right, .center {
       float: left;
     } 
     .clearfix:after {
       content: '';
       display: block;
       clear: both;
   	}
     .wrapper {
       padding: 0 100px;
     }
     .left {
       position: relative;
       left: -100px
       margin-left: -100%;
       width: 100px;
     }
     .right {
       position: relative;
       right: -100px;
       margin-left:-100px;
       width: 100px
     }
     .center {
       width: 100%;
     }
   </style>
   ```

2. 双飞翼布局

   ```html
   <boby>
     <div class="header">头部</div>
     <div class="wrapper">
       <div class="center">主区域</div>
     </div>
     <div class="left">左区域</div>
     <div class="right">右区域</div>
   </boby>
   
   <style>
     .wrapper {
       float: left;
       width: 100%;
     }
     .left {
       float: left;
       margin-left: -100%;
       width: 100px;
     }
     .right {
       float: left;
       margin-left: -100px;
       width: 100px
     }
     .center {
       margin: 0 100px;
     }
   </style>
   ```


### 24.什么是CSS reset

1. reset.css 是一个用来重置css样式的文件
2. normalize.css 为了增强跨浏览器渲染的一致性的CSS重置样式库

### 25.什么是css sprite（精灵图），有什么优缺点？

1. 精灵图是什么

   把多个小图标合成一张大图片

2. 优缺点
   - 优点：减少了http请求的次数，提升了性能
   - 缺点：可维护性差

### 26.`display:none;`与`visiblity:hidden;`的区别

1. 占用位置的区别

   - `display： none；`不占位置
   - `visiblity: hidden;` 占用位置

2. 重绘和回流

   `display: none;`:产生一次回流、一次重绘

   `visiblity: hidden;`:产生一次重绘

   产生回流的情况：改变元素的位置（left、top...）、显示隐藏元素...
   产生重绘的情况：样式改变...

### 27.opacity和rgba的区别

1. 共同：实现透明效果
   - opacity：取值在0~1之间，0表示透明，1表示不透明
   - rgba：R表示红色，G表示绿色，B表示蓝色，A表示透明度取值在0~1之间
2. 区别：
   - opacity的子代会继承父元素的透明属性
   - rgba的子代不会继承父元素的透明属性

