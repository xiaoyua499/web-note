# 前端面试题

## javascript面试题

### 1、javascript有哪些数据类型，它们的区别？

1. **一共8中数据类型**
   1. 基本数据类型(简单数据类型)：string/number/boolean/null/undefined/synbol/bigint
      1. symbol数据类型是ES6中新出的数据类型，创建（`Synbol()`）之后独一无二并且不可变，不能使用 `new Symbol()`创建
      2. Bigint数据类型是ES6中新出的数据类型,数据覆盖范围大，能够解决超出普通数据类型范围报错的问题
         1. 创建方法：
            - 整数末尾直接加n：647326483767797n
            - 调用BigInt()构造函数：BigInt("647326483767797")
   2. 复杂数据类型（引用数据类型）：object（对象、数组、正则）
2. **区别：**
   1. 声明变量时的存储分配
      1. 基本数据类型存储在栈中
      2. 复杂数据类型存储在堆中
   2. 不同的访问机制
      1. 基本数据类型可以直接访问
      2. 引用数据类型访问引用地址，根据引用地址找到堆中实体
   3. 复制变量时不同
      1. 基本数据类型：将原始值的副本赋值新的变量
      2. 引用数据类型：将引用地址赋值给新的值

### 2、闭包？

1. **什么是闭包？**

   方法里返回一个方法

   ```js
   function a(){
     let a1 = 1
     return function () {
       return a1
     }
   }
   ```

2. **闭包的意义**

   1. 延长变量的生命周期
   2. 创建私有环境

3. 例如`Vue`中

   ```js
   data(){
     return{
       
     }
   }
   ```


### 3、函数节流与防抖

1. **函数防抖**

   > 函数防抖（debounce），就是指触发事件后，在延迟时间内函数只能执行一次，如果触发事件后在延迟时间内又触发了事件，则会重新计算函数延执行时间。等延迟时间计时完毕，则执行目标代码。
   
   ```js
   封装防抖
   //func 要执行的函数，wait要等待的时间
   function debounce(func, wait) {
     let timeout;
     return function () {
       // 清空定时器
       if(timeout) clearTimeout(timeout);
       timeout = setTimeout(func, wait)
     }
   }
   ```

2. **函数节流**

   > 函数节流（throttle），在规定时间内，频繁触发的事件被限制为只允许触发一次
   
   **时间戳实现**
   
   ```js
   function throttle(fn, delay) {
     let previous = 0;
     // 使用闭包返回一个函数并且用到闭包函数外面的变量previous
     return function() {
         let args = arguments;
         let now = new Date();
         if(now - previous > delay) {
             fn.apply(this, args);
             previous = now;
         }
     }
   }
   ```
   
   **定时器实现**
   
   ```js
   function throttle(func, delay) {
     var delay = delay || 1000;
     var timer = null;
     return function(args) {
       var context = this;
       var nowDate = new Date();
       var now = nowDate.getTime();
       if (!timer) {
         timer = setTimeout(function() {
           func.call(context, args);
           timer = null;
         }, delay)
       }
     }
   ```
   

### 4、原型与原型链

1. **原型可以解决什么问题**

   对象共享属性和方法

2. **谁有原型**

   函数：`prototype`

   对象：`__proto__`

3. **对象查找属性或者方法的顺序**

   对象本身-->构造函数-->对象的原型-->构造函数的原型-->当前原型的原型中

4. **原型链**

   1. 是什么？

      把原型串联起来

   2. 原型链的最顶端是null

### 5、localStorage、sessionStorage、cookie的区别

1. 共同点

   在客户端存放数据

2. 区别

   1. 存放数据的有效期不同

      sessionStorage：仅在当前浏览器窗口有效，关闭后自动删除

      localStorage：始终有效、窗口或浏览器关闭也会一直存在，除非手动删除

      cookie：只在设置的cookie过期时间内有效

   2. 能过存储的容量不同

      cookie存储量不能超过4k

      localStorage、sessionStorage不能超过5M

      **注意**：不同的浏览器能存储的大小是不同的

### 6、延迟加载JS有哪些方式？

`async、defer`

例如：

```html
<script async type="text/javascript" src='script.js'></script>
<script defer type="text/javascript" src="script.js"></script>
```

defer:等html全部加载完成，才会执行js代码，顺次执行js脚本

async：async与html解析同步进行，按加载速度执行js脚本

<img src="https://images3.pianshen.com/626/e4/e4910fe7a9a6234e0f2096bbef6fdcd2.png" style="zoom:67%;" />

### 7、`null`和`undefined`的区别

**null**是一个表示“无”的对象（空对象指针），转为数值为0

**undefined**是一个表示“无”的原始值，转为数值为NaN

### 8、== 与 === 的区别

== ： 比较值

​	不同的类型进行比较时会通过调用valueOf转换（JavaScript 调用 `valueOf` 方法将对象转换为原始值。你很少需要自己调用 `valueOf` 方法；当遇到要预期的原始值的对象时，JavaScript 会自动调用它。）

=== ： 比较值与类型

### 9、JS微任务与宏任务

1. js是单线程语言

2. js代码执行流程：

   `同步任务==>事件循环【微任务(清空所有的微任务)==>宏任务】`

3. 事件循环(请求、定时器、事件...)
   1. 微任务：`promise.then`
   2. 宏任务:`setTimeout..`

例如：

```js
for(var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i)
  },1000*i)
}
console.log(2222)
//2222
//3
//3
//3

setTimeout(function () {
  console.log('1')
})
new Promise((resolve) => {
  console.log('promise 1')
  resolve()
}).then(() => {
  console.log('微1')
}).then(() => {
  console.log('微2')
})
console.log(2)

//promise 1
//2
//微1
//微2
//1
```

### 10、JS作用域

1. 除函数外，js没有块级作用域
2. 作用域链：内部可以访问外部的变量，外部不能访问内部的变量
3. 注意：JS有变量提示机制【变量悬挂声明】
4. 优先级：声明变量 > 声明普通函数 > 参数 > 变量提升

**面试时怎么看**

1. 本层作用域有没有此变量【变量提升】
2. 注意：js除函数外没有块级作用域
3. 注意：优先级

例题1：

```js
function c() {
  var b = 1;
  function a() {
    conso1e.1og(b）//undefined
    var b = 2;
    console.log(b) //2
  }
  a();
  console.log(b) //1
  }
c()
```

例题2：

```js
var name ='a'
function(){
  if(typeof name ='undefined')
    var name ='b';
    console.log('111'+name);
  }elsef
  	console.log('222'+name)
})()
// 111b
```

### 11、JS作用域+this指向+原型链

例题1：

```js
function Foo(){
  getName=function(){console.log(1)}//注意是全局的vindow,
  return this;
}
Foo.getName function(){console.log(2)}
Foo.prototype.getName function(){console.log(3)}
var getName function(){console.log(4)}
function getName(){
	console.log(5)
}
Foo.getName();//2
getName();//4
Foo().getName();//1
getName();//1
new Foo().getName();//3
```

例题2:

```js
var o = {
  a:10,
  b:{
    fn:function(){
      console.log(this.a)
      console.log(this)
   	 }
    }
}
o.b.fn();
//{fn:f}
```



例题3：

```js
//头条考题
window.name = 'ByteDance'
function A(){
	this.name = 123;
}
A.prototype.getA = function () {
  console.log(this )
  return this.name + 1;
}
let a = new A();
let funcA = a.getA;
/* 相当于 let funcA = function () {
console.log(this)
return this.name + 1;
}*/
funcA() //ByteDance1

//window
```

例题4：

```js
var length 10;
function fn(){
return this.length + 1;
}
var obj = {
  length:5,
  test1:function(){
    return fn();
  }
}
obj.test2 = fn;
console.log(obj.test1());//11
console.log(fn()===obj.test2());//false
console.log(obj.test1()==obj.test2());//false
```

### 12.判断变量是不是数组

1. isArray

   ```js
   var arr = [1,2,3]
   console.log(Array.isArray(arr))
   ```

2. instanceof

   ```js
   var arr = [1,2,3]
   console.log(arr instanceof Array)
   ```

3. 原型 prototype

   ```js
   var arr = [1,2,3]
   console.log(Object.prototype.toString.call(arr).indexOf('Array'))
   ```

4. isPrototypeOf()

   ```js
   var arr = [1,2,3]
   console.log(Array.prototype.isprototypeOf(arr))
   ```

5. constructor

   ```js
   var arr = [1,2,3]
   console.log(arr.constructor.toSting().indexOf('Array'))
   ```


### 13.`slice、splice`有什么功能,是否会改变原数组

1. `slice`用来截取数组

   `例如：slice(3)、slice(1,3)、slice(-3)`并且会返回一个新数组

2. `splice`用来：插入、删除、替换

   该方法会改变原数组并返回删除的元素

### 14.数组去重

1. `new Set`

   ```js
   var arr = [1, 3, 2, 2, 1, 4, 5, 5, 1, 3]
   function unique(arr) {
     return [...new Set(arr)]
     // return Array.from(new Set(arr))
   }
   console.log(unique(arr));
   ```

2. `indexOf`

   ```js
   var arr = [1, 3, 2, 2, 1, 4, 5, 5, 1, 3]
   function unique(arr) {
     var arr1 = []
     for (var i = 0; i < arr.length; i++) {
       if (arr1.indexOf(arr[i]) == -1) {
         arr1.push(arr[i])
       }
     }
     return arr1
   }
   console.log(unique(arr));
   ```

3. `sort`

   ```js
   var arr = [1, 3, 2, 2, 1, 4, 5, 5, 1, 3]
   function unique(arr) {
     arr = arr.sort()
     var arr1 = []
     for (var i = 0; i < arr.length; i++) {
       if (arr[i] !== arr[i + 1]) {
         arr1.push(arr[i])
       }
     }
     return arr1
   }
   console.log(unique(arr));
   ```

### 15.大数组中包含了4个小数组，分别找到每个小数组中的最大值然后把它们串联起来，形成一个新数组

例：

```js
var arr = [
  [4, 5, 1, 3],
  [13, 27, 18, 26],
  [32, 35, 37, 39],
  [1000, 1001, 587, 1]
]
function fnArr(arr) {
  var newArr = []
  arr.forEach((item) => {
    newArr.push(Math.max(...item))
  })
  return newArr
}
console.log(fnArr(arr));
```

### 16.给字符串对象定义一个addPrefix函数当传入一个字符串str时，它会返回新的带有指定前缀的字符串

例如：`console.log("world".addPrefix("hello")) 控制台会输出："helloworld"`

```js
String.prototype.addPrefix = function (str) {
  return str + this
}
console.log('world'.addPrefix('hello'));
```

### 17.找出字符串中出现次数最多的字符及其出现的次数

例题1：

```js
var str = 'jjjjjjsdfsdijfhaliuyewhjhjhweufghmnnvzxcvj'
function getMaxCount(str) {
  var maxCount = 0
  var maxCountChar = ''
  while (str) {
    var length = str.length
    var char = str.charAt(0)
    var reg = new RegExp(char, 'g')
    str = str.replace(reg, '')
    var newLength = str.length
    var charCount = length - newLength
    if (charCount > maxCount) {
      maxCount = charCount
      maxCountChar = char
    }
  }
  return {
    maxCount,
    maxCountChar
  }
}
maxCountChar = getMaxCount(str).maxCountChar
maxCount = getMaxCount(str).maxCount
console.log('出现最多的字符为：' + maxCountChar);
console.log('出现的次数为：' + maxCount);
```

### 18.new操作符具体做了什么

1. 创建了一个空的对象
2. 将空对象的原型，指向构造函数的原型
3. 将空对象作为构造函数的上下文（改变this指向）
4. 对构造函数有返回值的处理判断

```js
//手写 new
function Fun (age,name) {
  this.age = age
  this.name = name
}
function cerate (fn, ...args) {
  //1. 创建了一个空的对象
  var obj = {}
  //2. 将空对象的原型，指向构造函数的原型
  Object.setPrototypeOf(obj,fn.prototype)
  //3. 将空对象作为构造函数的上下文（改变this指向）
  var result = fn.apply(obj,args)
  //4. 对构造函数有返回值的处理判断
  return result instanceof Object ? result : obj
}
console.log(create(Fun,18,'张三'))
```

### 19.`call、apply、bind`的区别

1. 共同点：
   1. 可以改变this指向
   2. 语法：函数.call()、函数.apply()、函数.bind()
2. 区别
   1. call、apply会立即执行，bind返回的是一个函数而不会立即执行需要加（）才会执行
   2. 参数不同：apply第二个参数为数组的形式而call和bind有多个参数是需要逐一书写

### 20.`sort`

1. 用sort()对[3,15,8,29,102,22]排序

<img src="D:\Desktop\文件\web\web 笔记\图片\uTools_1659444863701.png" style="zoom: 33%;" />

2. 当function(x,y)得到的返回值小于0，x会被移动到y前面(升序排序)

```js
 var arr = [1,22,113,12,45,32,334]
 console.log(arr.sort(function(x,y){
   return x - y
 }));
//[1, 12, 22, 32, 45, 113, 334]
```

3. 当function(x,y)得到的返回值大于0，x会被移动到y后面(降序排序)

```js
var arr = [1,22,113,12,45,32,334]
console.log(arr.sort(function(x,y){
   return y - x
}));
//[334, 113, 45, 32, 22, 12, 1]
```

4. 当function(x,y)得到的返回值等于0，x和y的位置相对不变（不是所有浏览器都遵守）

### 21.深拷贝与浅拷贝

1. 共同点：都是复制

2. 区别：

   1. 浅拷贝：只复制引用，不复制值

   2. 深拷贝：复制值

      ```js
      var obj = {
        a:1,
        b:2
      }
      var obj4 = JSON.parse(JSON.stringIfy(obj))
      ```

      

