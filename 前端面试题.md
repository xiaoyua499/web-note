# 前端面试题

## javascript面试题

### 1、javascript有哪些数据类型，它们的区别？

1. **一共8中数据类型**
   1. 基本数据类型(简单数据类型)：string/number/boolean/null/undefined/synbol/bigint
      1. symbol数据类型是ES6中新出的数据类型，创建（`Synbol()`）之后独一无二并且不可变，不能使用 `new Symbol()`创建
      2. Bigint数据类型是ES6中新出的数据类型,数据覆盖范围大，能够解决超出普通数据类型范围报错的问题
         1. 创建方法：
            - 整数末尾直接加n：647326483767797n
            - 调用BigInt()构造函数：BigInt("647326483767797")
   2. 复杂数据类型（引用数据类型）：object（对象、数组、正则）
2. **区别：**
   1. 声明变量时的存储分配
      1. 基本数据类型存储在栈中
      2. 复杂数据类型存储在堆中
   2. 不同的访问机制
      1. 基本数据类型可以直接访问
      2. 引用数据类型访问引用地址，根据引用地址找到堆中实体
   3. 复制变量时不同
      1. 基本数据类型：将原始值的副本赋值新的变量
      2. 引用数据类型：将引用地址赋值给新的值

### 2、闭包？

1. **什么是闭包？**

   方法里返回一个方法

   ```js
   function a(){
     let a1 = 1
     return function () {
       return a1
     }
   }
   ```

2. **闭包的意义**

   1. 延长变量的生命周期
   2. 创建私有环境

3. 例如`Vue`中

   ```js
   data(){
     return{
       
     }
   }
   ```


### 3、函数节流与防抖

1. **函数防抖**

   > 函数防抖（debounce），就是指触发事件后，在延迟时间内函数只能执行一次，如果触发事件后在延迟时间内又触发了事件，则会重新计算函数延执行时间。等延迟时间计时完毕，则执行目标代码。
   
   ```js
   封装防抖
   //func 要执行的函数，wait要等待的时间
   function debounce(func, wait) {
     let timeout;
     return function () {
       // 清空定时器
       if(timeout) clearTimeout(timeout);
       timeout = setTimeout(func, wait)
     }
   }
   ```

2. **函数节流**

   > 函数节流（throttle），在规定时间内，频繁触发的事件被限制为只允许触发一次
   
   **时间戳实现**
   
   ```js
   function throttle(fn, delay) {
     let previous = 0;
     // 使用闭包返回一个函数并且用到闭包函数外面的变量previous
     return function() {
         let args = arguments;
         let now = new Date();
         if(now - previous > delay) {
             fn.apply(this, args);
             previous = now;
         }
     }
   }
   ```
   
   **定时器实现**
   
   ```js
   function throttle(func, delay) {
     var delay = delay || 1000;
     var timer = null;
     return function(args) {
       var context = this;
       var nowDate = new Date();
       var now = nowDate.getTime();
       if (!timer) {
         timer = setTimeout(function() {
           func.call(context, args);
           timer = null;
         }, delay)
       }
     }
   ```
   

### 4、原型与原型链

1. **原型可以解决什么问题**

   对象共享属性和方法

2. **谁有原型**

   函数：`prototype`

   对象：`__proto__`

3. **对象查找属性或者方法的顺序**

   对象本身-->构造函数-->对象的原型-->构造函数的原型-->当前原型的原型中

4. **原型链**

   1. 是什么？

      把原型串联起来

   2. 原型链的最顶端是null

### 5、localStorage、sessionStorage、cookie的区别

1. 共同点

   在客户端存放数据

2. 区别

   1. 存放数据的有效期不同

      sessionStorage：仅在当前浏览器窗口有效，关闭后自动删除

      localStorage：始终有效、窗口或浏览器关闭也会一直存在，除非手动删除

      cookie：只在设置的cookie过期时间内有效

   2. 能过存储的容量不同

      cookie存储量不能超过4k

      localStorage、sessionStorage不能超过5M

      **注意**：不同的浏览器能存储的大小是不同的

### 6、延迟加载JS有哪些方式？

`async、defer`

例如：

```html
<script async type="text/javascript" src='script.js'></script>
<script defer type="text/javascript" src="script.js"></script>
```

defer:等html全部加载完成，才会执行js代码，顺次执行js脚本

async：async与html解析同步进行，按加载速度执行js脚本

<img src="https://images3.pianshen.com/626/e4/e4910fe7a9a6234e0f2096bbef6fdcd2.png" style="zoom:67%;" />

### 7、`null`和`undefined`的区别

**null**是一个表示“无”的对象（空对象指针），转为数值为0

**undefined**是一个表示“无”的原始值，转为数值为NaN

八、== 与 === 的区别

== ： 比较值

​	不同的类型进行比较时会通过调用valueOf转换（JavaScript 调用 `valueOf` 方法将对象转换为原始值。你很少需要自己调用 `valueOf` 方法；当遇到要预期的原始值的对象时，JavaScript 会自动调用它。）

=== ： 比较值与类型

### 8、JS微任务与宏任务

1. js是单线程语言

2. js代码执行流程：

   `同步任务==>事件循环【微任务(清空所有的微任务)==>宏任务】`

3. 事件循环(请求、定时器、事件...)
   1. 微任务：`promise.then`
   2. 宏任务:`setTimeout..`

例如：

```js
for(var i = 0; i < 3; i++) {
  setTimeout(function () {
    console.log(i)
  },1000*i)
}
console.log(2222)
//2222
//3
//3
//3

setTimeout(function () {
  console.log('1')
})
new Promise((resolve) => {
  console.log('promise 1')
  resolve()
}).then(() => {
  console.log('微1')
}).then(() => {
  console.log('微2')
})
console.log(2)

//promise 1
//2
//微1
//微2
//1
```

九、JS作用域

1. 除函数外，js没有块级作用域
2. 作用域链：内部可以访问外部的变量，外部不能访问内部的变量
3. 注意：JS有变量提示机制【变量悬挂声明】
4. 优先级：声明变量 > 声明普通函数 > 参数 > 变量提示

**面试时怎么看**

1. 本层作用域有没有此变量【变量提升】
2. 注意：js除函数外没有块级作用域
3. 注意：优先级

例题1：

```js
function c(){
  var b 1;
  function a(){
    conso1e.1og(b）//undefined
    var b 2;
    console.log(b ) //2
  }
  a();
  console.log(b ) //1
  }
c()
```

例题2：

```js
var name ='a'
function(){
  if(typeof name ='undefined')
    var name ='b';
    console.log('111'+name);
  }elsef
  	console.log('222'+name)
})()
// 111b
```

### 9、JS作用域+this指向+原型链

例题1：

```js
function Foo(){
  getName=function(){console.log(1)}//注意是全局的vindow,
  return this;
}
Foo.getName function(){console.log(2)}
Foo.prototype.getName function(){console.log(3)}
var getName function(){console.log(4)}
function getName(){
	console.log(5)
}
Foo.getName();//2
getName();//4
Foo().getName();//1
getName();//1
new Foo().getName();//3
```

例题2:

```js
var o = {
  a:10,
  b:{
    fn:function(){
      console.log(this.a)
      console.log(this)
   	 }
    }
}
o.b.fn();
//{fn:f}
```



例题3：

```js
//头条考题
window.name = 'ByteDance'
function A(){
	this.name = 123;
}
A.prototype.getA = function () {
  console.log(this )
  return this.name + 1;
}
let a new A();
let funcA = a.getA;
/* 相当于 let funcA = function () {
console.log(this)
return this.name + 1;
}*/
funcA() //ByteDance1

//window
```

例题4：

```js
var length 10;
function fn(){
return this.length 1;
}
var obj = {
  length:5,
  test1:function(){
    return fn();
  }
}
obj.test2 = fn;
console.log(obj.test1());//11
console.log(fn()===obj.test2());//false
console.log(obj.test1()==obj.test2());//false
```

10.判断变量是不是数组

1. isArray

   ```js
   var arr = [1,2,3]
   console.log(Array.isArray(arr))
   ```

2. instanceof

   ```js
   var arr = [1,2,3]
   console.log(arr instanceof Array)
   ```

3. 原型 prototype

   ```js
   var arr = [1,2,3]
   console.log(Object.prototype.toString.call(arr).indexOf('Array'))
   ```

4. isPrototypeOf()

   ```js
   var arr = [1,2,3]
   console.log(Array.prototype.isprototypeOf(arr))
   ```

5. constructor

   ```js
   var arr = [1,2,3]
   console.log(arr.constructor.toSting().indexOf('Array'))
   ```

   
