# 正则表达式

正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为"元字符"）。

正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。

```js
var input = document.querySelector('.input')
  input.oninput=function(){
    var str = input.value
    var reg = /^\d+$/ 
    console.log(str); //123
    console.log(reg.test(str));//true
```

## 编写正则表达式

### 1. 创建方式

1. **字面量创建方式**

   两个斜杠之间包起来的，都是用来描述规则的元字符

   ```js
   var reg = /^\d+$/
   ```

2. **构建函数模式创建**

   使用正则对象new的方式，写成字符串形式

   ```js
   let reg = new RegExp('\\d+')
   ```

### 2.正则表达式的组成

1. **元字符**

   |  字符  | 描述                                                         |
   | :----: | :----------------------------------------------------------- |
   |   \    | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。 |
   |   ^    | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。 |
   |   $    | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。 |
   |   *    | 匹配前面的子表达式零次或多次。                               |
   |   +    | 匹配前面的子表达式一次或多次。                               |
   |   ?    | 匹配前面的子表达式零次或一次。                               |
   |  {n}   | n 是一个非负整数。匹配确定的 n 次。                          |
   |  {n,}  | n 是一个非负整数。至少匹配n 次。                             |
   | {n,m}  | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。 |
   |  x\|y  | 匹配 x 或 y。                                                |
   | [xyz]  | 字符集合。匹配所包含的任意一个字符。                         |
   | [^xyz] | 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。 |
   | [a-z]  | 字符范围。匹配指定范围内的任意字符。                         |
   | [^a-z] | 负值字符范围。匹配任何不在指定范围内的任意字符。             |
   |   \b   | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 |
   |   \B   | 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |
   |   \d   | 匹配一个数字字符。                                           |
   |   \D   | 匹配一个非数字字符。                                         |
   |   \n   | 匹配一个换行符。                                             |
   |   \r   | 匹配一个回车符。                                             |
   |   \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。             |
   |   \S   | 匹配任何非空白字符。                                         |
   |   \t   | 匹配一个制表符。                                             |
   |   \w   | 匹配字母、数字、下划线。                                     |

2. **修饰符**

   | 修饰符 | 描述                                                         |
   | ------ | ------------------------------------------------------------ |
   | i      | 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。 |
   | g      | 查找所有的匹配项。                                           |
   | m      | 使边界字符 **^** 和 **$** 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。 |
   | s      | 默认情况下的圆点 **.** 是匹配除换行符 **\n** 之外的任何字符，加上 **s** 修饰符之后, **.** 中包含换行符 \n。22 |

3. **英文句号**

   英文句号 `.` 是元字符的最简单的例子。元字符 `.` 可以匹配任意单个字符。它不会匹配换行符和新行的字符。例如正则表达式 `.ar`，表示：任意字符后面跟着一个字母 `a`， 再后面跟着一个字母 `r`。

   ```js
   ".ar" => The car parked in the garage.
   ```

4. **字符组**

   ​	字符组是一组写在圆括号内的子模式 `(...)`。正如我们在正则表达式中讨论的那样，如果我们把一个量词放在一个字符之后，它会重	复前一个字符。 但是，如果我们把量词放在一个字符组之后，它会重复整个字符组。 例如正则表达式 `(ab)*` 表示匹配零个或多个的字	符串“ab”。我们还可以在字符组中使用元字符 `|`。例如正则表达式 `(c|g|p)ar`，表示：小写字母 `c`、`g` 或 `p` 后面跟字母 `a`，后跟字	母 `r`。

   ```js
   "(c|g|p)ar" => The car is parked in the garage.
   ```

5. **转义特殊字符**

   正则表达式中使用反斜杠 `\` 来转义下一个字符。这将允许你使用保留字符来作为匹配字符 `{ } [ ] / \ + * . $ ^ | ?`。在特殊字符前面加 `\`，就可以使用它来做匹配字符。 例如正则表达式 `.` 是用来匹配除了换行符以外的任意字符。现在要在输入字符串中匹配 `.` 字符，正则表达式 `(f|c|m)at\.?`，表示：小写字母 `f`、`c` 或者 `m` 后跟小写字母 `a`，后跟小写字母 `t`，后跟可选的 `.` 字符。

   ```js
   "(f|c|m)at\.?" => The fat cat sat on the mat.
   ```

6. **插入符号**

   插入符号 `^` 符号用于检查匹配字符是否是输入字符串的第一个字符。如果我们使用正则表达式 `^a`（如果 a 是起始符号）匹配字符串 `abc`，它会匹配到 `a`。 但是如果我们使用正则表达式 `^b`，它是匹配不到任何东西的，因为在字符串 `abc` 中“b”不是起始字符。 让我们来看看另一个正则表达式 `^(T|t)he`，这表示：大写字母 `T` 或小写字母 `t` 是输入字符串的起始符号，后面跟着小写字母 `h`，后跟小写字母 `e`。

   ```js
   "(T|t)he" => The car is parked in the garage.
   "^(T|t)he" => The car is parked in the garage.
   ```

### 3.断言

​	后行断言和先行断言有时候被称为断言，它们是特殊类型的 ***非捕获组***（用于匹配模式，但不包括在匹配列表中）。当我们在一种特定模式之前或者之后有这种模式时，会优先使用断言。 例如我们想获取输入字符串 `$4.44 and $10.88` 中带有前缀 `$` 的所有数字。我们可以使用这个正则表达式 `(?<=\$)[0-9\.]*`，表示：获取包含 `.` 字符且前缀为 `$` 的所有数字。 以下是正则表达式中使用的断言：

  | 符号 | 描述         |
  | ---- | ------------ |
  | ?=   | 正向先行断言 |
  | ?!   | 负向先行断言 |
  | ?<=  | 正向后行断言 |
  | ?<!  | 负向后行断言 |

1. **正向先行断言**
	
	 正向先行断言认为第一部分的表达式的后面必须是先行断言表达式。返回的匹配结果仅包含与第一部分表达式匹配的文本。 要在一个括号内定义一个正向先行断言，在括号中问号和等号是这样使用的 `(?=...)`。先行断言表达式写在括号中的等号后面。 例如正则表达式 `(T|t)he(?=\sfat)`，表示：匹配大写字母 `T` 或小写字母 `t`，后面跟字母 `h`，后跟字母 `e`。 在括号中，我们定义了正向先行断言，它会引导正则表达式引擎匹配后面跟着 `fat` 的 `The` 或 `the`。

  ```
  "(T|t)he(?=\sfat)" => The fat cat sat on the mat.
  ```

2. **负向先行断言**

  	当我们需要指定第一部分表达式的后面不跟随某一内容时，使用负向先行断言。负向先行断言的定义跟我们定义的正向先行断言一样， 唯一的区别在于我们使用否定符号 `!` 而不是等号 `=`，例如 `(?!...)`。 我们来看看下面的正则表达式 `(T|t)he(?!\sfat)`，表示：从输入字符串中获取全部 `The` 或者 `the` 且不匹配 `fat` 前面加上一个空格字符。

  ```
  "(T|t)he(?!\sfat)" => The fat cat sat on the mat.
  ```

3. **正向后行断言**

  	正向后行断言用于获取跟随在特定模式之后的所有匹配内容。正向后行断言表示为 `(?<=...)`。例如正则表达式 `(?<=(T|t)he\s)(fat|mat)`，表示：从输入字符串中获取在单词 `The` 或 `the` 之后的所有 `fat` 和 `mat` 单词。

  ```
  "(?<=(T|t)he\s)(fat|mat)" => The fat cat sat on the mat.
  ```

4. **负向后行断言**

  	负向后行断言是用于获取不跟随在特定模式之后的所有匹配的内容。负向后行断言表示为 `(?<!...)`。例如正则表达式 `(?<!(T|t)he\s)(cat)`，表示：在输入字符中获取所有不在 `The` 或 `the` 之后的所有单词 `cat`。

  ```
  "(?<!(T|t)he\s)(cat)" => The cat sat on cat.
  ```

### 4. 标记

  	标记也称为修饰符，因为它会修改正则表达式的输出。这些标志可以以任意顺序或组合使用，并且是正则表达式的一部分。

  | 标记 | 描述                                       |
  | ---- | ------------------------------------------ |
  | i    | 不区分大小写：将匹配设置为不区分大小写。   |
  | g    | 全局搜索：搜索整个输入字符串中的所有匹配。 |
  | m    | 多行匹配：会匹配输入字符串每一行。         |

  1. **不区分大小写**

  `i` 修饰符用于执行不区分大小写匹配。例如正则表达式 `/The/gi`，表示：大写字母 `T`，后跟小写字母 `h`，后跟字母 `e`。 但是在正则匹配结束时 `i` 标记会告诉正则表达式引擎忽略这种情况。正如你所看到的，我们还使用了 `g` 标记，因为我们要在整个输入字符串中搜索匹配。

  ```
  "The" => The fat cat sat on the mat.
  "/The/gi" => The fat cat sat on the mat.
  ```

  2. **全局搜索**

  	`g` 修饰符用于执行全局匹配（会查找所有匹配，不会在查找到第一个匹配时就停止）。 例如正则表达式 `/.(at)/g`，表示：除换行符之外的任意字符，后跟小写字母 `a`，后跟小写字母 `t`。 因为我们在正则表达式的末尾使用了 `g` 标记，它会从整个输入字符串中找到每个匹配项。

  ```
  ".(at)" => The fat cat sat on the mat.
  "/.(at)/g" => The fat cat sat on the mat.
  ```

  3. **多行匹配**

  	`m` 修饰符被用来执行多行的匹配。正如我们前面讨论过的 `(^, $)`，使用定位符来检查匹配字符是输入字符串开始或者结束。但是我们希望每一行都使用定位符，所以我们就使用 `m` 修饰符。 例如正则表达式 `/at(.)?$/gm`，表示：小写字母 `a`，后跟小写字母 `t`，匹配除了换行符以外任意字符零次或一次。而且因为 `m` 标记，现在正则表达式引擎匹配字符串中每一行的末尾。

  ```
  "/.at(.)?$/" => The fat
                  cat sat
                  on the mat.
  "/.at(.)?$/gm" => The fat
                    cat sat
                    on the mat.
  ```

## 常用正则表达式

- **正整数**：`^\d+$`
- **负整数**：`^-\d+$`
- **电话号码**：`^+?[\d\s]{3,}$`
- **电话代码**：`^+?[\d\s]+(?[\d\s]{10,}$`
- **整数**：`^-?\d+$`
- **用户名**：`^[\w\d_.]{4,16}$`
- **字母数字字符**：`^[a-zA-Z0-9]*$`
- **带空格的字母数字字符**：`^[a-zA-Z0-9 ]*$`
- **密码**：`^(?=^.{6,}$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$`
- **电子邮件**：`^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4})*$`
- **IPv4 地址**：`^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$`
- **小写字母**：`^([a-z])*$`
- **大写字母**：`^([A-Z])*$`
- **网址**：`^(((http|https|ftp):\/\/)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]]){2,4}([[a-zA-Z0-9]\/+=%&_\.~?\-]*))*$`
- **VISA 信用卡号码**：`^(4[0-9]{12}(?:[0-9]{3})?)*$`
- **日期（MM/DD/YYYY）**：`^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]{2}$`
- **日期（YYYY/MM/DD）**：`^(19|20)?[0-9]{2}[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$`
- **万事达信用卡号码**：`^(5[1-5][0-9]{14})*$`

